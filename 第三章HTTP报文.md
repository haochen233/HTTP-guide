如果说 HTTP 是因特网的信使，那么 HTTP 报文就是它用来搬东西的包裹了。

# 3.1 报文流
HTTP 报文是在 HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的元信息（meta-information）开头，，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入” 、 “流出” 、 “上游”及“下游”都是用来描述报文方向的。

## 3.1.1报文流入源端服务器
HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向。报文流入源端服务器，工作完成之后，会流回用户的 Agent 代理中，

## 3.1.2 报文向下游流动
HTTP报文会像河水一样流动。不管是请求报文还是响应报文。所有报文都会向下游流动，所有报文的发送者在接收者的上游（upstream）。

# 3.2 报文的组成部分
HTTP报文是简单的格式化数据块。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应，他们由三个部分组成：对报文进行描述的起始行（start line）、包含属性的首部（header）块，以及可选的，包含数据的主体（body）部分。

## 3.2.1 报文的语法
所有的 HTTP 报文都可以分为两类：请求报文（request message）和响应报文（response message）请求报文会向 Web 服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同。

请求报文的格式：  

```
<method> <request-URL><version>
<headers>

<entity-body>
```

这是响应报文的格式（注意，只有起始行的语法有所不同）:  

```
<version> <status><reason-phrase>
<headers>

<entity-body>
```

下面是对各部分的简要描述:  
- 方法（method）  
客户端希望服务器对资源执行的动作。是一个单独的单词，比如GET、HEAD或POST。

- 请求URL （request-URL）  
命名了所请求的资源，或者URL路径组件的完整URL。

- 版本（version）  
报文所使用的HTTP版本，其格式看起来是这样的：  
`HTTP/<major>:<minor>`其中主要版本号（major）和次要版本号（minor）都是整数。

- 状态码（status-code）  **这三位数字描述了请求过程中所发生的情况**。每个状态码的第一位数字都用于描述状态的一般类别（ “成功” 、 “出错”等）。每个状态码的第一位数字都用于描述状态的一般类别（ “成功” 、 “出错”等）

- 原因短语（reason-phrase）  
相当于对状态码的注解一样，比如`HTTP/1.0 200 OK`,`OK`就是原因短语。只对人类阅读有意义。

- 首部（header）  
可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:）,然后是一个可选的空格，接着是一个值（可以理解为一个键值对，比如`content-length: 16`，意思为内容长度为16字节），最后是一个CRLF首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。

- 实体的主体部分（entity-body）  
实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分

> 注意，一组 HTTP 首部总是应该以一个空行（仅有 CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实
体的主体部分时， （错误地）省略了最后的 CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个 CRLF 的报文。

## 3.2.2 起始行
所有的 HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。

### 1.请求行
请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行。包含了一个方法和一个请求 URL，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。请求行中还包含 HTTP 的版本，用来告知服务器，客户端使用的是哪种 HTTP。

所有这些字段都有空格符分隔。例如：`GET /test/hi-there.txt HTTP/1.1`。

### 2.响应行
响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行。，包含了响应报文使用的 HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语。例如：`HTTP/1.1 200 OK`，HTTP版本为1.1，状态码为200（成功），原因短语为OK。

### 3.方法
请求的起始行以方法作为开始，方法用来告知服务器要做些什么。

常用的HTTP方法：  
| 方法 | 描述 | 是否包含主体 |
| --- | --- | --- |
| GET | 从服务器获取一份文档 | 否 |
| HEAD | 只从服务器获取文档的首部 | 否 |
| POST |向服务器发送需要处理的数据 | 是 | 
| PUT | 将请求的主体部分存储在服务器上 | 是 |
| TRACE | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否 | 
| OPTIONS | 决定可以在服务器上执行哪些方法 | 否 |
| DELETE | 从服务器上删除一份文档 | 否 | 

---

并不是所有服务器都实现了所有的这7中方法。而且，由于HTTP设计得易于扩展，所以除了这些方法之外，其他服务器可能还会实现一些自己的请求方法。**这些附加的方法是对 HTTP 规范的扩展，因此被称为扩展方法。**

### 4.状态码
方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。

可以通过三位数字代码对不同状态码进行分类。

下面列出**状态码的分类**：  
| 整体范围 | 已定义范围 | 分类 | 
| --- | --- | --- | 
| 100~199 | 100~101 | 信息提示 | 
| 200~299 | 200~206 | 成功 | 
| 300~399 | 300~305 | 重定向 |
| 400~499 | 400~415 | 客户端错误 | 
| 500~599 | 500~505 | 服务器错误 | 


> 如果收到了不认识的状态码，可能是有人将其作为当
前协议的扩展定义的。可以根据其所处范围，将它作为那个类别中一个普通的成员
来处理。比如状态码 `515`在定义的范围之外，就可以跟据开头数字5确定分类，这条响应应该指出了服务器错误。

常见的状态码：  
| 状态码 | 原因短语 | 含义 |
| --- | --- | --- | 
| 200 | OK | 成功。请求的所有数据都在响应主体中 | 
| 401 | Unauthorized(未授权) |  需要输入用户名和密码 |
| 404 | Not Found | 服务器无法找到所请求 URL 对应的资源 |
---

### 5.原因短语
原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况。

HTTP 规范并没有提供任何硬性规定，要求原因短语以何种形式出现。

只是有一些，状态码和一些建议使用的原因短语。

### 6.版本号
版本号会以 HTTP/x.y 的形式出现在请求和响应报文的起始行中。为 HTTP 应用程序提供了一种将自己所遵循的协议版本告知对方的方式。

### 3.2.3 首部

### 1.首部分类
HTTP 规范定义了几种首部字段。应用程序也可以随意发明自己所用的首部。HTTP首部可以分为以下几类。

- 通用首部  
既可以出现在请求报文中，也可以出现在响应报文中。

- 请求首部  
提供更多有关请求的信息。

- 响应首部  
提供更多有关响应的信息。

- 实体首部  
描述主体的长度和内容，或者资源自身

- 扩展首部  
规范中没有定义的新首部。

每个 HTTP 首部都有一种简单的语法：名字后面跟着冒号（ ：） ，然后跟上可选的空格，再跟上字段值，最后是一个 CRLF。

常见的首部实例：  
| 首部实例 | 描述 | 
| --- | --- |
| Date:Tue,3Oct 1997 02:16:03 GMT | 服务器产生响应的日期 | 
| Content-length:15040 | 实体的主体部分包含了 15040 字节的数据 | 
| Content-type:image/gif | 实体的主体部分是一个 GIF 图片 | 
| Accept: image/gif, image/jpeg, text/html | 客户端可以接收GIF图片和JPEG图片以及HTML |
---

### 2.首部延续行
将长的首部行分为多行可以提高可读性多出来的每行前面至少要有一个空格或制表符（tab）

> 类似Golang中使用Println输出一个很长的字符串，可以写在多行上，而不是一行，这样代码更易于阅读。

例如：  

```
HTTP/1.0 200 OK
Content-Type: image/gif
Content-Length: 6666
Server: Test Server
    Version 1.0
```

在本例中server首部的值，被写成多行。

## 3.2.4 实体的主体部分
HTTP 报文的第三部分是可选的实体主体部分。实体的主体是 HTTP 报文的负荷。就是 HTTP 要传输的内容。

HTTP 报文可以承载很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等。

> HTTP/0.9 报文也由请求和响应组成，但请求中只包含方法和请求 URL，响应中只包含实体。它没有版本信息 ，没有状态码或原因短语，也没有首部。

# 3.3 方法
并不是每个服务器都实现了所有的方法，即使服务器实现了所有这些方法，这些方法的使用很可能也是受限的。

> 比如DELETE方法和PUT方法，服务器可能并不希望任何人都能够删除或存储资源。这些限制通常都是在服务器的配置中进行设置的，因此会随着站点和服务器的不同而有所不同。

## 3.3.1 安全方法
HTTP 定义了一组被称为安全方法的方法。GET 方法和 HEAD 方法都被认为是安全的。

## 3.3.2 GET
GET 是最常用的方法。通常用于请求服务器发送某个资源。

## 3.3.3 HEAD
HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。使用 HEAD，可以：  
- 在不获取资源的情况下了解资源的情况（比如判断类型）
- 通过查看响应中的状态码，看看某个对象是否存在；
- 通过查看首部，测试资源是否被修改

## 3.3.4 PUT
与GET从服务器读取文档相反，PUT方法会向服务器写入文档。

PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。

>因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录。

## 3.3.5 POST
POST 方法起初是用来向服务器输入数据的。实际上，通常会用它来支持 HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如说发送到一个服务器网管程序中，然后由这个程序对其进行处理）。

> 注意POST向服务器发送数据，而PUT用于向服务器存储数据。

## 3.3.6 TRACE
客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。

TRACE会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以检查，原始报文是否被毁坏或修改过（实现了对请求报文的追踪）。

## 3.3.7 OPTIONS
OPTIONS 方法请求 Web 服务器告知其支持的各种功能。

## 3.3.8 DELETE 
DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。

## 3.3.9扩展方法
Web发布扩展方法示例：  

| 方法 | 描述 | 
| --- | --- |
| LOCK | 允许用户“锁定资源”——比如，可以在编辑某个资源的时候将其锁定，以防别人同时对其进行修改 |
| COPY | 便于在服务器上复制资源 | 
| MOVE | 在服务器上移动资源 |
---

# 3.4 状态码
HTTP 状态码被分成了五大类。

## 3.4.1 100～199——信息性状态码

| 状态码 | 原因短语 | 含义 | 
| --- | --- | --- |
| 100 | Continue | 说明收到了请求的初始部分，请客户端继续。发送了这个状态码之后，服务器在收到请求之后必须进行响应。 | 
| 101 | Switching Protocols | 说明服务器正在根据客户端的指定，将协议切换成 Update 首部所列的协议 | 
---

## 3.4.2 200～299——成功状态码
客户端发起请求时，这些请求通常都是成功的。服务器有一组用来表示成功的状态码，分别对应于不同类型的请求。

| 状态码 | 原因短语 | 含义 | 
| --- | --- | --- |
| 200 | OK | 请求没问题，实体的主体部分包含了所请求的资源。 |
| 202 | Accepted | 请求已被接受，但服务器还未对其执行任何动作。不能保证服务器会完成这个请求；这只是意味着接受请求时，它看起来是有效的 | 
---

## 3.4.3 300～399——重定向状态码
| 状态码 | 原因短语 | 含义 | 
| --- | --- | --- |
| 300 | Multiple Choices | 客户端请求一个实际指向多个资源的 URL 时会返回这个状态码 | 
| 301 | Moved Permanently | 在请求的 URL 已被移除时使用。响应的 Location 首部中应该包含资源现在所处的 URL |
---

## 3.4.4 400～499——客户端错误状态码
| 状态码 | 原因短语 | 含义 | 
| --- | --- | --- |
| 400 | Bad Request | 用于告知客户端它发送了一个错误的请求 | 
| 401 | Unauthorized | 与适当的首部一同返回，在这些首部中请求客户端在获取对资源的访问权之前，对自己进行认证。 | 
| 403 | Forbidden | 用于说明请求被服务器拒绝了 | 
| 404 | Not Found | 用于说明服务器无法找到所请求的 URL。通常会包含一个实体，比如服务器自定义的404html文档 | 
| 405 | Method Not Allowed | 发起的请求中带有所请求的 URL 不支持的方法时，使用此状态码。应该在响应中包含 Allow 首部，以告知客户端对所请求的资源可以使用哪些方法。 | 
| 406 | Not Acceptable | 客户端可以指定它们愿意接受什么类型的实体。服务器没有与客户端可接受的 URL 相匹配的资源时，使用此代码。 |
---

## 3.4.5 500~599————服务器错误状态码
有时客户端发送了一条有效请求，服务器自身却出错了。这可能是客户端碰上了服务器的缺陷，或者服务器上的子元素，比如某个网关资源，出了错。

| 500 | Internal Server Error | 服务器遇到一个妨碍它为请求提供服务的错误时，使用此状态码 | 
| 501 | Not Implemented | 客户端发起的请求超出服务器的能力范围 | 
| 502 | Gateway Timeout | 作为代理或网关使用的服务器从请求响应链的下一条链路上收到了
一条伪响应（比如，它无法连接到其父网关）时，使用此状态码 | 
| 503 | Service Unavailable | 服务器现在无法为请求提供服务 |

# 3.5 首部
在请求和响应报文中都可以用首部来提供信息，有些首部是某种报文专用的，有些首部则更通用一些。可以将首部分为五个主要的类型。

- 通用首部  
这些是客户端和服务器都可以使用的通用首部。可以在客户端、服务器和其他应用程序之间提供一些非常有用的通用功能。比如，Date 首部就是一个通用首部。每一端都可以用它来说明构建报文的时间和日期。

- 请求首部  
从名字中就可以看出，请求首部是请求报文特有的。它们为服务器提供了一些额
外信息，比如客户端希望接收什么类型的数据。例如，下面的 Accept 首部就用
来告知服务器客户端会接受与其请求相符的任意媒体类型。比如：`Accept text/plain`

- 响应首部  
响应报文有自己的首部集，以便为客户端提供信息（比如，客户端在与哪种类型
的服务器进行交互） 。例如，下列 Server 首部就用来告知客户端它在与一个版本为`Apache`的服务器进行交互：`Server: Apache`

- 实体首部  
实体首部指的是用于应对实体主体部分的首部。比如：`Content-Length: 666`主体长度为666字节

- 扩展首部  
扩展首部是非标准的首部，由应用程序开发者创建。即使不知道这些扩展首部的含义，HTTP 程序也要接受它们并对其进行转发。
